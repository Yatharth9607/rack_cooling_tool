# -*- coding: utf-8 -*-
"""
Created on Tue Jun 25 08:19:27 2019

@author: SESA539950
"""

from scipy.optimize import fsolve
import numpy as np

simulation = ['AC Unit', 'Ventilation Fans (Economizer Mode)']
simulation_options = ['AC Fans on UPS', 'Vent Fans on UPS']

simulation01 = ['AC Unit', 'Front Ventilation Fan (Economizer Mode)',
                'Rear Ventilation Fan (Economizer Mode)', 'Both Ventilation Fans (Economizer Mode)']
simulation_options01 = ['AC Fans (on UPS)', 'Front Ventilation Fan (on UPS)',
                        'Rear Ventilation Fan (on UPS)',
                        'Front Ventilation Fan (on UPS)', 'Rear Ventilation Fan (on UPS)', 'Both Ventilation Fans (on UPS)']

w = 2  # Door width [ft]

rho = 1.19  # Density of air [kg/m^3]
Cp = 1005.0  # Specific heat capacity of air [J/kg-K]

a_AC = 117137.3  # Flow resistance of AC fan [Pa/(m^3/s)^2]
e_IT = 0.8  # Effectiveness of heat exchanger in IT servers + UPS

# C_AC = 26*650        # Thermal mass of AC [J/K]
# e_AC = 0.8           # Effectiveness of heat exchanger in AC

Q = np.zeros(10)
P = np.zeros(4)
dt = 1


class FNMsolver:

    def __init__(self, ss_condition, AC_option, VF_option, size_rack, n_IT, q_IT, n_BP, T_AC, T_amb, size_UPS, q_UPS,
                 t_max, size_AC, Q_AC_max, Q_VF_max, P_AC_stag, P_VF_stag, a_FL, a_RL):
        self.ss_condition = ss_condition  # Steady-state Simulation condition
        self.tr_condition = ss_condition  # Transient Simulation condition
        self.AC_option = AC_option  # AC Fans on UPS
        self.VF_option = VF_option  # Vent Fans on UPS
        self.size_rack = size_rack  # Rack size in U
        self.h = self.size_rack * 6.5 / 42  # Door height [ft]
        self.n_IT = n_IT  # Total IT population in rack (U)
        self.C_IT = n_IT * 11.3 * 650  # Thermal mass of IT servers + UPS [J/K]
        self.q_IT = q_IT * 1000  # Total IT power (kW to W converted)
        self.Q_IT = 0.125 * self.q_IT * 0.0004719474  # Total IT airflow rate [m^3/s]
        self.n_BP = n_BP  # Number of blanking panels
        self.T_AC = (T_AC - 32) * 5 / 9 + 273.15  # AC set point temperature [K]
        self.T_amb = (T_amb - 32) * 5 / 9 + 273.15  # Ambient Temperature [K]
        self.size_UPS = size_UPS  # Size of UPS (U)
        self.C_UPS = self.size_UPS * 11.3 * 650  # Thermal mass of UPS [J/K]
        self.C_IT = self.C_IT + self.C_UPS  # Thermal mass of IT servers + UPS [J/K]
        self.q_UPS = q_UPS * 1000 * 0.1  # Heat generated by UPS (10% of rated power) (kW to W converted)
        self.t_max = 60 * t_max  # Total simulation time (s)
        self.size_AC = size_AC  # Size of cooling unit (U)
        self.C_AC = self.size_AC * 26 * 650  # Thermal mass of AC
        self.q_AC = q_IT * 1000  # Cooling capacity of AC (W)
        self.Q_AC_max = Q_AC_max * 0.0004719474  # Open flow rate (cfm to m^3/s converted)
        self.Q_VF_max = Q_VF_max * 0.0004719474
        self.P_AC_stag = P_AC_stag * 248.84  # Stagnation pressure (inH2O to Pa converted)
        self.P_VF_stag = P_VF_stag * 248.84
        self.a_FL = 10 ** a_FL
        self.a_RL = 10 ** a_RL

    # Nomenclature of resistances, airflow rates and pressure terms

    # Q_IT = Q[0]
    # Q_AC = Q[1]
    # Q_SP = Q[2]
    # Q_L = Q[3]
    # Q_VF_f = Q[4]
    # Q_VF_r = Q[5]
    ## Q_FD = Q[6]
    ## Q_FP = Q[7]
    ## Q_RD = Q[8]
    ## Q_RP = Q[9]
    #
    # P_1 = P[0]
    # P_2 = P[1]
    ## P_1_f = P[2]
    ## P_2_r = P[3]
    #
    # a_AC = {a_AC: .2f}
    # a_SP = {a_SP: .2f}
    ## a_FD = {a_FD: .2f}
    ## a_FP = {a_FP: .2f}
    # a_FL = {a_FL: .2f}
    ## a_RD = {a_RD: .2f}
    ## a_RP = {a_RP: .2f}
    # a_RL = {a_RL: .2f}

    def flowRes(self):
        if (self.size_rack - self.n_IT - self.n_BP - self.size_UPS - self.size_AC) == 0.0:
            a_SP = 1530.5 * (6.5 / self.h) ** 2  # Server plane resistance measured from St. Louis data
        elif (self.size_rack - self.n_IT - self.n_BP - self.size_UPS - self.size_AC) > 0.0:
            b_SP = (self.size_rack - self.n_IT - self.size_UPS - self.size_AC - self.n_BP) / (
                    self.size_rack - self.n_IT - self.size_UPS - self.size_AC)
            f_SP = (1 / b_SP ** 2) * (1 + (0.5 * (1 - b_SP) ** 0.75) + (1.414 * (1 - b_SP) ** 0.375))
            a_SP = f_SP * rho / (2 * (0.905 * (
                    self.size_rack - self.n_IT - self.size_UPS - self.size_AC) / self.size_rack) ** 2)  # Rear area of rack (size of 42 U) = 0.905 m^2

        # if self.ss_condition == simulation01[1] or self.VF_option == [simulation_options01[1]] or self.VF_option == [simulation_options01[3]]:
        #     a_FL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2
        #     a_RL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2
        #
        # elif self.ss_condition == simulation01[2] or self.VF_option == [simulation_options01[2]] or self.VF_option == [simulation_options01[4]]:
        #     a_FL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2
        #     a_RL = 0.01 * self.a_RL * 1530.5 * (6.5 / self.h) ** 2
        #
        # elif self.ss_condition == simulation01[3] or self.VF_option == [simulation_options01[1], simulation_options01[2]] or self.VF_option == [simulation_options01[2], simulation_options01[1]] or self.VF_option == [simulation_options01[5]]:
        #     a_FL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2
        #     a_RL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2

        if self.ss_condition == simulation01[0] and not self.VF_option:
            a_FL = self.a_FL * 1530.5 * (6.5 / self.h) ** 2
            a_RL = self.a_FL * 1530.5 * (6.5 / self.h) ** 2

        else:
            a_FL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2
            a_RL = 0.01 * self.a_FL * 1530.5 * (6.5 / self.h) ** 2

        a = [a_SP, a_FL, a_RL]
        return a

    # AC Unit ON, Both VF OFF
    def case_1(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[1] - self.Q_AC_max * (1 - (P[0] - P[1]) / self.P_AC_stag)
        f[2] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[3] = Q[3] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[4] = Q[3] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])
        f[5] = Q[3] + Q[1] - Q[0] - Q[2]
        f[6] = Q[4]
        f[7] = Q[5]

        return f

    # Both VF ON, AC Unit OFF
    def case_2(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[4] - self.Q_VF_max * (1 - (P[0] / self.P_VF_stag))
        f[2] = Q[5] - self.Q_VF_max * (1 - (-P[1]) / self.P_VF_stag)
        f[3] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[4] = Q[1] - np.sign(P[1] - P[0]) * np.sqrt(np.abs(P[1] - P[0]) / a_AC)
        f[5] = Q[3] - Q[2] + Q[1] - Q[0]
        f[6] = Q[3] - Q[4] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[7] = Q[3] - Q[5] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])

        return f

    # Front VF ON, AC Unit OFF
    def case_2a(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[4] - self.Q_VF_max * (1 - (P[0] / self.P_VF_stag))
        f[2] = Q[5]
        f[3] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[4] = Q[1] - np.sign(P[1] - P[0]) * np.sqrt(np.abs(P[1] - P[0]) / a_AC)
        f[5] = Q[3] - Q[2] + Q[1] - Q[0]
        f[6] = Q[3] - Q[4] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[7] = Q[3] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])

        return f

    # Rear VF ON, AC Unit OFF
    def case_2b(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[4]
        f[2] = Q[5] - self.Q_VF_max * (1 - (-P[1]) / self.P_VF_stag)
        f[3] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[4] = Q[1] - np.sign(P[1] - P[0]) * np.sqrt(np.abs(P[1] - P[0]) / a_AC)
        f[5] = Q[3] - Q[2] + Q[1] - Q[0]
        f[6] = Q[3] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[7] = Q[3] - Q[5] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])

        return f

    # AC Unit OFF, Both VF OFF
    def case_3(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[1] - np.sign(P[1] - P[0]) * np.sqrt(np.abs(P[1] - P[0]) / a_AC)
        f[2] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[3] = Q[3] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[4] = Q[3] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])
        f[5] = Q[3] + Q[1] - Q[0] - Q[2]
        f[6] = Q[4]
        f[7] = Q[5]

        return f

    # AC Unit ON, Both VF ON
    def case_4(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[4] - self.Q_VF_max * (1 - (P[0] / self.P_VF_stag))
        f[2] = Q[5] - self.Q_VF_max * (1 - (-P[1]) / self.P_VF_stag)
        f[3] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[4] = Q[1] - self.Q_AC_max * (1 - (P[0] - P[1]) / self.P_AC_stag)
        f[5] = Q[3] - Q[2] + Q[1] - Q[0]
        f[6] = Q[3] - Q[4] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[7] = Q[3] - Q[5] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])

        return f

    # AC Unit ON, Front VF ON
    def case_4a(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[4] - self.Q_VF_max * (1 - (P[0] / self.P_VF_stag))
        f[2] = Q[5]
        f[3] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[4] = Q[1] - self.Q_AC_max * (1 - (P[0] - P[1]) / self.P_AC_stag)
        f[5] = Q[3] - Q[2] + Q[1] - Q[0]
        f[6] = Q[3] - Q[4] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[7] = Q[3] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])

        return f

    # AC Unit ON, Rear VF ON
    def case_4b(self, z):
        Q = z[0:6]
        P = z[6:8]
        f = np.zeros(8)

        a = self.flowRes()

        f[0] = Q[0] - self.Q_IT
        f[1] = Q[4]
        f[2] = Q[5] - self.Q_VF_max * (1 - (-P[1]) / self.P_VF_stag)
        f[3] = Q[2] - np.sign(P[0] - P[1]) * np.sqrt(np.abs(P[0] - P[1]) / a[0])
        f[4] = Q[1] - self.Q_AC_max * (1 - (P[0] - P[1]) / self.P_AC_stag)
        f[5] = Q[3] - Q[2] + Q[1] - Q[0]
        f[6] = Q[3] - np.sign(-P[0]) * np.sqrt(np.abs(P[0]) / a[1])
        f[7] = Q[3] - Q[5] - np.sign(P[1]) * np.sqrt(np.abs(P[1]) / a[2])

        return f

    def calcAirflow_tr(self):
        if self.AC_option == [simulation_options01[0]]:
            if not self.VF_option:
                z = fsolve(self.case_1, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = abs(Q[1]) / abs(Q[0])

            elif self.VF_option == [simulation_options01[1]] or self.VF_option == [simulation_options01[3]]:
                z = fsolve(self.case_4a, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = (abs(Q[1]) + abs(Q[4])) / abs(Q[0])

            elif self.VF_option == [simulation_options01[2]] or self.VF_option == [simulation_options01[4]]:
                z = fsolve(self.case_4b, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = (abs(Q[1]) + abs(Q[4])) / abs(Q[0])

            else:
                z = fsolve(self.case_4, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = (abs(Q[1]) + abs(Q[0])) / abs(Q[0])

        elif self.AC_option != [simulation_options01[0]]:
            if self.VF_option == [simulation_options01[1]] or self.VF_option == [simulation_options01[3]]:
                z = fsolve(self.case_2a, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = abs(Q[4]) / abs(Q[0])

            elif self.VF_option == [simulation_options01[2]] or self.VF_option == [simulation_options01[4]]:
                z = fsolve(self.case_2b, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = abs(Q[4]) / abs(Q[0])

            elif not self.VF_option:
                z = fsolve(self.case_3, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = 0.0

            else:
                z = fsolve(self.case_2, np.ones(8))
                Q = z[0:6]
                P = z[6:8]
                gr = abs(Q[4]) / abs(Q[0])

        return Q, P, gr

    def calcAirflow_ss(self):
        if self.ss_condition == simulation01[0]:
            z = fsolve(self.case_1, np.ones(8))
            Q = z[0:6]
            P = z[6:8]
            gr = abs(Q[1]) / abs(Q[0])

        elif self.ss_condition == simulation01[1]:
            z = fsolve(self.case_2a, np.ones(8))
            Q = z[0:6]
            P = z[6:8]
            gr = abs(Q[4]) / abs(Q[0])

        elif self.ss_condition == simulation01[2]:
            z = fsolve(self.case_2b, np.ones(8))
            Q = z[0:6]
            P = z[6:8]
            gr = abs(Q[4]) / abs(Q[0])

        elif self.ss_condition == simulation01[3]:
            z = fsolve(self.case_2, np.ones(8))
            Q = z[0:6]
            P = z[6:8]
            gr = abs(Q[4]) / abs(Q[0])

        return Q, P, gr

    # Energy Equations Solver

    # Case-1 when q_AC is less than q_IT
    def energySS_1(self, T):

        Q, _, _ = self.calcAirflow_ss()

        e_AC = 0.8 * (abs(Q[1]) / 0.2067) ** (-0.2)
        if e_AC > 1.0:
            e_AC = 1.0

        # Calculate the initial temperture based on the steady state condition:
        f = np.zeros(6)

        f[0] = -rho * Cp * abs(Q[0]) * T[2] + rho * Cp * (max(Q[0], 0) * T[1] - min(Q[0], 0) * T[4]) + self.q_IT
        f[1] = e_IT * T[0] + (1 - e_IT) * ((max(Q[0], 0) * T[1] - min(Q[0], 0) * T[4]) / abs(Q[0])) - T[2]
        f[2] = -rho * Cp * abs(Q[1]) * T[5] + rho * Cp * (max(Q[1], 0) * T[4] - min(Q[1], 0) * T[
            1]) - self.q_AC / 1.001  # To include ineffectiveness of the AC
        f[3] = e_AC * T[3] + (1 - e_AC) * ((max(Q[1], 0) * T[4] - min(Q[1], 0) * T[1]) / abs(Q[1])) - T[5]
        f[4] = -min(Q[0], 0) * T[2] + max(Q[1], 0) * T[5] - min(Q[2], 0) * T[4] + max(Q[3] + Q[4], 0) * self.T_amb - (
                max(Q[0], 0) - min(Q[1], 0) + max(Q[2], 0) - min(Q[3] + Q[4], 0)) * T[1]
        f[5] = max(Q[0], 0) * T[2] - min(Q[1], 0) * T[5] + max(Q[2], 0) * T[1] - min(Q[3] + Q[4], 0) * self.T_amb - (
                -min(Q[0], 0) + max(Q[1], 0) - min(Q[2], 0) + max(Q[3] + Q[4], 0)) * T[4]

        return f

    # Case-2 when q_AC is greater than or equal to q_IT
    def energySS_2(self, T):

        Q, _, _ = self.calcAirflow_ss()
        e_AC = 0.8 * (abs(Q[1]) / 0.2067) ** (-0.2)
        if e_AC > 1.0:
            e_AC = 1.0
        dT_IT = self.q_IT / (rho * Cp * abs(Q[0]))

        f = np.zeros(6)

        f[0] = T[0] - T[1] - dT_IT / e_IT
        f[1] = T[1] - (- min(Q[2], 0) * T[4] + max(Q[1], 0) * T[5] + max(Q[3], 0) * self.T_amb) / (
                Q[0] + max(Q[2], 0) - min(Q[1], 0) - min(Q[3], 0))
        f[2] = T[2] - T[1] - dT_IT
        f[3] = T[3] - ((max(Q[1], 0) * T[4] - min(Q[1], 0) * T[1]) / abs(Q[1]) + (
                T[5] - (max(Q[1], 0) * T[4] - min(Q[1], 0) * T[1]) / abs(Q[1])) / e_AC)
        f[4] = T[4] - (Q[0] * T[2] + max(Q[2], 0) * T[1] - min(Q[3], 0) * self.T_amb) / (
                - min(Q[2], 0) + max(Q[1], 0) + max(Q[3], 0))
        f[5] = T[5] - self.T_AC

        return f

    # Case-3 when AC is not running on power
    def energySS_3(self, T):

        Q, _, _ = self.calcAirflow_ss()
        dT_IT = self.q_IT / (rho * Cp * abs(Q[0]))

        f = np.zeros(6)

        f[0] = T[0] - T[1] - dT_IT / e_IT
        f[1] = T[1] - (- min(Q[2], 0) * T[4] + max(Q[1], 0) * T[5] + max(Q[3], 0) * self.T_amb) / (
                Q[0] + max(Q[2], 0) - min(Q[1], 0) - min(Q[3], 0))
        f[2] = T[2] - T[1] - dT_IT / e_IT
        f[3] = T[3] - (T[5] + (max(Q[1], 0) * T[4] - min(Q[1], 0) * T[1]) / abs(Q[1])) / 2
        f[4] = T[4] - (Q[0] * T[2] + max(Q[2], 0) * T[1] - min(Q[3], 0) * self.T_amb) / (
                - min(Q[2], 0) + max(Q[1], 0) + max(Q[3], 0))
        f[5] = T[5] - (max(Q[1], 0) * T[1] - min(Q[1], 0) * T[4]) / abs(Q[1])

        return f

    def initial_T(self):

        # T = np.ones(6)

        if self.ss_condition == simulation01[0]:
            if self.q_AC >= self.q_IT:
                T = fsolve(self.energySS_2, np.ones(6))
            else:
                T = fsolve(self.energySS_1, np.ones(6))

        else:
            T = fsolve(self.energySS_3, np.ones(6))

        return T

    def energyTR(self):

        # Solve initial temperature

        T = self.initial_T()

        T_IT_inlet = np.ones(self.t_max)
        T_IT_inlet[0] = T[1]

        # Solve transient temperature

        A = np.zeros((6, 6))
        B = np.zeros(6)

        Q, _, _ = self.calcAirflow_tr()

        e_AC = 0.8 * (abs(Q[1]) / 0.2067) ** (-0.2)
        if e_AC > 1.0:
            e_AC = 1.0

        for i in range(1, int(self.t_max / dt)):
            A[0, 0] = self.C_IT / dt
            A[0, 1] = -rho * Cp * max(Q[0], 0)
            A[0, 2] = rho * Cp * abs(Q[0])
            A[0, 4] = rho * Cp * min(Q[0], 0)
            A[1, 0] = e_IT
            A[1, 1] = (1 - e_IT) * max(Q[0], 0) / abs(Q[0])
            A[1, 2] = -1
            A[1, 4] = -(1 - e_IT) * (min(Q[0], 0)) / abs(Q[0])
            A[2, 1] = rho * Cp * min(Q[1], 0)
            A[2, 3] = self.C_AC / dt
            A[2, 4] = -rho * Cp * max(Q[1], 0)
            A[2, 5] = rho * Cp * abs(Q[1])
            A[3, 1] = -(1 - e_AC) * min(Q[1], 0) / abs(Q[1])
            A[3, 3] = e_AC
            A[3, 4] = (1 - e_AC) * max(Q[1], 0) / abs(Q[1])
            A[3, 5] = -1
            A[4, 1] = -max(Q[0], 0) + min(Q[1], 0) - max(Q[2], 0) + min(Q[3], 0)
            A[4, 2] = -min(Q[0], 0)
            A[4, 4] = -min(Q[2], 0)
            A[4, 5] = max(Q[1], 0)
            A[5, 1] = max(Q[2], 0)
            A[5, 2] = max(Q[0], 0)
            A[5, 4] = min(Q[0], 0) - max(Q[1], 0) + min(Q[2], 0) - max(Q[3], 0)
            A[5, 5] = -min(Q[1], 0)

            B[0] = self.q_IT + self.q_UPS + (self.C_IT / dt) * T[0]
            B[2] = self.C_AC / dt * T[3]
            B[4] = -max(Q[3], 0) * self.T_amb
            B[5] = min(Q[3], 0) * self.T_amb

            T = np.dot(np.linalg.inv(A), B)

            T_IT_inlet[i] = T[1]

        return T_IT_inlet

    def calcTemp(self):

        T_transient = self.energyTR()

        T_initial = T_transient[0] * np.ones(20)
        T_IT_inlet = np.ones(20 + np.size(T_transient))
        T_IT_inlet[0:20] = T_initial
        T_IT_inlet[20:] = T_transient
        T_IT_inlet = (T_IT_inlet - 273.15) * 9 / 5 + 32  # Temperature in degree F
        T_rec = 80.6 * np.ones(np.size(T_IT_inlet))
        time = np.arange(-20, np.size(T_IT_inlet) - 20)

        return T_IT_inlet, T_rec, time
